/*              NODO DE CONTROL ANGULAR 
Este nodo recibe posiciones angulares deseadas (roll, pitch y yaw), velocidades angulares deseadas orientacion del dorne y velocidad angulare real del drone. 
Con ello calcula los torques necsarios para la dinamico.
*/
#include "ros/ros.h"
#include "geometry_msgs/Twist.h"
#include "geometry_msgs/Vector3.h"
#include <cmath>
#include <eigen3/Eigen/Dense>

// Declaración de variables globales
double roll, pitch, yaw, rollp, pitchp, yawp;
double roll_d, pitch_d, yaw_d, rollp_d, pitchp_d, yawp_d;

// Ganancias del controlador PD angular virtual 
double kpx = 8;
double kpy = 8;
double kpz = 8;
double kdx = 8;
double kdy = 8;
double kdz = 8;

// Inercias
double jxx = 0.0411;
double jyy = 0.0478;
double jzz = 0.0599;
// roll, pitch y yaw dos puntos = 0
int roll2 = 0;
int pitch2 = 0;
int yaw2 = 0;

// Funcion callback para mensajes del topico pos_des angulares
void pitchRollDesCallback(const geometry_msgs::Twist::ConstPtr& msg)
{
    roll_d = msg->angular.x;
    pitch_d = msg->angular.y;
}
void yawDesCallback(const geometry_msgs::Twist::ConstPtr& msg)
{
    yaw_d = msg->angular.z;
}

// Funcion callback para mensajes del topico vels_des angulares
void velsDesCallback(const geometry_msgs::Twist::ConstPtr& msg)
{
  rollp_d = msg->angular.x;
  pitchp_d = msg->angular.y;
  yawp_d = msg->angular.z;
}

// Funcion callback para mensajes del topico pos_real
void rotRealCallback(const geometry_msgs::Twist::ConstPtr& msg)
{
  roll = msg->angular.x;
  pitch = msg->angular.y;
  yaw = msg->angular.z;
}

// Funcion callback para mensajes del topico vels_real
void rot_puntoRealCallback(const geometry_msgs::Twist::ConstPtr& msg)
{
  rollp = msg->angular.x;
  pitchp = msg->angular.y;
  yawp = msg->angular.z;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "angular_control");
  ros::NodeHandle nh3;

  // Subscripcion al topico de posicion angular deseada 
  ros::Subscriber pitchRoll_des_sub = nh3.subscribe("/ang_des", 100, pitchRollDesCallback);
  ros::Subscriber yaw_des_sub = nh3.subscribe("/pos_des", 100, yawDesCallback);

  // Subscripcion al topico de velocidad angular deseada
  ros::Subscriber vels_des_sub = nh3.subscribe("/vels_des", 100, velsDesCallback);

  // Subscripcion al topico de pitch, roll y yaw calculados en el control de posicion lineal
  ros::Subscriber pos_real_sub = nh3.subscribe("/pos_real", 100, rotRealCallback);

  // Subscripcion al topico de pitch, roll y yaw calculados en el control de posicion lineal
  ros::Subscriber vels_real_sub = nh3.subscribe("/vels_real", 100, rot_puntoRealCallback);

  // Creación del publicador para los torques
  ros::Publisher torque_pub = nh3.advertise<geometry_msgs::Vector3>("/torque", 100);

  ros::Rate loop_rate(100);

  while(ros::ok){
    geometry_msgs::Vector3 torque_var;

    // Calculos de errores
    double ex_ang = roll - roll_d; 
    double ey_ang = pitch - pitch_d;
    double ez_ang = yaw - yaw_d;  
    double ex_punto_ang = rollp - rollp_d;
    double ey_punto_ang = pitchp - pitchp_d;
    double ez_punto_ang = yawp - yawp_d;

    //Controladores virtuales
    double ux = -kpx*ex_ang - kdx*ex_punto_ang;
    double uy = -kpy*ey_ang - kdy*ey_punto_ang;
    double uz = -kpz*ez_ang - kdz*ez_punto_ang;

    //Calculo de torques
    double Tx = jxx * (((jzz - jyy) / jxx * pitchp * yawp) + roll2 + ux);
    double Ty = jyy * (((jxx - jzz) / jyy * rollp * yawp) + pitch2 + uy);
    double Tz = jzz * (((jyy - jxx) / jzz * rollp * pitchp) + yaw2 + uz);

    // Publicar torques
    torque_var.x = Tx;
    torque_var.y = Ty;
    torque_var.z = Tz;
    torque_pub.publish(torque_var);

    ros::spinOnce();
    loop_rate.sleep();
  }

  return 0;
}
